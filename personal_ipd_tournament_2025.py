# -*- coding: utf-8 -*-
"""personal ipd tournament 2025

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T_N_JfiXfL9wCaHBU0Zv12r5t4blObCm

#READ ME
Read these two articles if you are not familiar with Python:
1.   [Python Basics](https://medium.com/the-renaissance-developer/python-101-the-basics-441136fb7cc3)
2.   [Python Data Structures](https://medium.com/the-renaissance-developer/python-101-data-structures-a397bcc2bd30)
<br>


To Create Your Own Custom function you need to define a function in the form like this:

```
def function_name(my_moves, other_moves, current_round):
    return True # This means the function will make the player rat.
    # Code after this will NOT run
```


```
def another_function(my_moves, other_moves, current_round):
    if current_round == 10:
      return True #This means that if the currend round equals 10, this player  will rat
      # Code here will not run
     
     #However if the above condition is not met, it will not run the code in the if statement and continue below
     return False
     # Code here will not run
```



Every function will have access to 3 variables: <br>


1.  `my_moves` is a list of moves this player has made. This list is updated after every round. Ex: `[False, True, True, True]`   (This means the player has stayed silent on the first round and ratted every round after)<br>
2. `other_moves` is a list of moves the other player has made. This list is updated after every round. Ex: `[True, False, False, False]` (This means the other player ratted on the first round and stayed silent every round after)
3. `current_round` is an integer representing the number of rounds already played. Ex: `25` or `0`




IMPORTANT INDEXING NOTE: Python starts counting from 0. That means the first round will be the 0th round. To access the first round's decision, you must write `my_moves[0]` or `other_moves[0]` NOT `my_moves[1]` or `other_moves[1]`
"""

from functools import total_ordering
# @title Simulation Code (check it out if you want to, but make sure to run it by hitting the play button)


# Do not touch anything here (ignore this cell)
import random
import pandas as pd
import time
import json
import numpy as np
from IPython.display import display

def play_match(player1, player2, blindness, payoff_dict, rounds):
    total = 0
    player1TrueMoves = []
    player2TrueMoves = []
    player1ObsMoves = []
    player2ObsMoves = []
    player1currentreturnedmoves = []
    player2currentreturnedmoves = []
    results = {}
    results["score"] = [0, 0]
    invalidGame = False

    for i in range(rounds):
        # get moves, make sure they are booleans or lists of booleans
        if player1currentreturnedmoves:
            player1move = player1currentreturnedmoves.pop(0)
        else:
            player1move = player1(
                player1TrueMoves, player2ObsMoves, i
            )

        if player2currentreturnedmoves:
            player2move = player2currentreturnedmoves.pop(0)
        else:
            player2move = player2(
                player2TrueMoves, player1ObsMoves, i
            )

        if not (type(player1move) is bool or (type(player1move) is list and len(player1move) > 0 and type(player1move[0]) is bool)):
            print(f"On round {i} {player1.__name__} returned {player1move}, which is not allowed")
            invalidGame = True
            break

        if not (type(player2move) is bool or (type(player2move) is list and len(player2move) > 0 and type(player2move[0]) is bool)):
            print(f"On round {i} {player2.__name__} returned {player2move}, which is not allowed")
            invalidGame = True
            break

        if type(player1move) is list:
            player1currentreturnedmoves = player1move.copy()
            player1move = player1currentreturnedmoves.pop(0)

        if type(player2move) is list:
            player2currentreturnedmoves = player2move.copy()
            player2move = player2currentreturnedmoves.pop(0)

        player1ObsMoves.append(not player1move if (blindness[0] != 0 and random.random() < blindness[0]) else player1move)
        player1TrueMoves.append(player1move)
        player2ObsMoves.append(not player2move if (blindness[1] != 0 and random.random() < blindness[1]) else player2move)
        player2TrueMoves.append(player2move)

    # replay through game and score
    if not invalidGame:
        for i in range(rounds):
            # payoff matrix
            results["score"][0] += payoff_dict[(player1TrueMoves[i], player2TrueMoves[i])]
            results["score"][1] += payoff_dict[(player2TrueMoves[i], player1TrueMoves[i])]

            results["details"] = [player1TrueMoves, player2TrueMoves]
        total += results["score"][0]
    else:
        results["score"] = [None, None]
    return total, results


def run_no_noise_tournament(strats, rounds, payoff, seed=None):
    payoff_dict = {
        (False, False): payoff[0],
        (True, False): payoff[1],
        (False, True): payoff[2],
        (True, True): payoff[3]
    }

    data = {}
    for player1 in strats:
        data_player1 = {}
        player1_total = 0
        for player2 in strats:
            if seed is not None:
                np.random.seed(seed)
                random.seed(seed)
            total, results = play_match(player1, player2, [0, 0], payoff_dict, rounds)
            data_player1[player2.__name__] = results
            player1_total += total

        data_player1["Average"] = round(player1_total / len(strats), 2)
        data_player1["Total"] = player1_total
        data[player1.__name__] = data_player1
    return data


def run_noise_tournament(strats, rounds, blindness, num_rounds_to_avg, payoff, seeds=None):
    payoff_dict = {
        (False, False): payoff[0],
        (True, False): payoff[1],
        (False, True): payoff[2],
        (True, True): payoff[3]
    }

    data = {}
    for player1 in strats:
        data_player1 = {}
        player1_total = 0
        for player2 in strats:
            total_over_rounds = 0
            data_player1[player2.__name__] = {}
            data_player1[player2.__name__]["score"] = [0, 0]
            data_player1[player2.__name__]["details"] = []


            for i in range(num_rounds_to_avg):
                if seeds is not None:
                    np.random.seed(seeds[i])
                    random.seed(seeds[i])
                total, results = play_match(player1, player2, blindness, payoff_dict, rounds)
                total_over_rounds += total
                data_player1[player2.__name__]["score"][0] += results["score"][0]
                data_player1[player2.__name__]["score"][1] += results["score"][1]
                data_player1[player2.__name__]["details"].append(results["details"])
            data_player1[player2.__name__]["score"][0] /= num_rounds_to_avg
            data_player1[player2.__name__]["score"][1] /= num_rounds_to_avg
            player1_total += total_over_rounds


        data_player1["Average"] = round(player1_total / len(strats) / num_rounds_to_avg, 2)
        data_player1["Total"] = player1_total
        data[player1.__name__] = data_player1
    return data

def display_results(data):
    clean = {}
    for strategy1 in data:
        clean[strategy1] = {}
        for strategy2 in data[strategy1]:
            if isinstance(data[strategy1][strategy2], dict):
                clean[strategy1][strategy2] = data[strategy1][strategy2]['score']
            else:
                clean[strategy1][strategy2] = data[strategy1][strategy2]

    df = pd.DataFrame(data=clean).T.sort_index(axis=1)
    display(df)

def display_matchup_observed_history(data, player1, player2, complete_history=False, i=None):
    print(f"results for {player1.__name__} vs {player2.__name__}:")
    print(f"score: {data[player1.__name__][player2.__name__]['score']}")
    if i is None:
        details = data[player1.__name__][player2.__name__]['details']
    else:
        details = data[player1.__name__][player2.__name__]['details'][i]

    player1_moves = details[0]
    player2_moves = details[1]

    moves_df = pd.DataFrame({
            f'{player1.__name__}': player1_moves,
            f'{player2.__name__}': player2_moves
        })
    if complete_history:
        with pd.option_context('display.max_rows', None):
            display(moves_df)
    else:
        display(moves_df)


def test_function(function):
    test_cases = [[[True] * i, [False] * i, i] for i in range(0, 300)]

    has_error = False
    for test_case in test_cases:
        try:
            my_moves = test_case[0]
            my_moves_copy = my_moves.copy()
            other_moves = test_case[1]
            other_moves_copy = other_moves.copy()
            output = function(my_moves_copy, other_moves_copy, test_case[2])
            if my_moves != my_moves_copy or other_moves != other_moves_copy:
                print(f"On round {test_case[2]} your function {function.__name__} modified the input arrays, which is not allowed")
                return
                # for anyone snooping around in the code: this is not how
                # the actual simulation will be run, the functions will not
                # be checked for if it modifies the input arrays, we will
                # just pass in copies of the arrays
            if not (output is True or output is False or (type(output) is list and len(output) > 0) and type(output[0]) is bool ):
                print(f"On round {test_case[2]} your function {function.__name__} returned {output}, which is not True or False or a list of bools")
                return
        except Exception as e:
            print(f"ERROR\nOn round {test_case[2]} your function {function.__name__} produced the following error:\n{e}")
            has_error = True
    if not has_error:
        print("Your function works :)")

# @title Default Functions (run them)

import random


def rat(my_moves, other_moves, current_round):
    # Always Rats (returns True)
    return True


def silent(my_moves, other_moves, current_round):
    # Always stays silent (returns False)
    return False


def rand(my_moves, other_moves, current_round):
    random_number = random.random()
    if random_number < 0.5:
        return True
    else:
        return False


def kinda_random(my_moves, other_moves, current_round):
    cheat_probability = 0.9
    if random.random() < cheat_probability:
        return True
    return False


def tit_for_tat(my_moves, other_moves, current_round):
    if len(other_moves) == 0:
        return False
    if other_moves[-1]:
        return True
    return False


def tit_for_two_tats(my_moves, other_moves, current_round):
    if len(other_moves) < 2:
        return False
    return other_moves[-1] and other_moves[-2]


def nuke_for_tat(my_moves, other_moves, current_round):
    if len(other_moves) == 0:
        return False
    if other_moves[-1] == True:
        return [True] * 200
    return False


def nuke_for_two_tats(my_moves, other_moves, current_round):
    if len(other_moves) < 2:
        return False
    indices = [i for i, x in enumerate(other_moves) if x]
    for i in range(len(indices) - 1):
        if indices[i] == indices[i + 1] - 1:
            return True
    return False


def nuke_for_five_tats(my_moves, other_moves, current_round):
    # Stays silent until the other player rats five times. If the other player's rats 5 times this player rats forever.
    if len(other_moves) == 0:
        return False
    num_of_betray = 0
    for i in other_moves:
        if i:
            num_of_betray += 1
    if (
        num_of_betray > 4
    ):  # you can change the 4 here to make this a nukeForXtats (remember that the number here should be one less than the number of tats)
        return [True] * 200
    return False


def two_tits_for_tat(my_moves, other_moves, current_round):
    if current_round == 0:
        return False
    if (current_round >= 1 and other_moves[-1]) or (
        current_round >= 2 and other_moves[-2]
    ):
        return True
    return False


def get_angry_after_twenty(my_moves, other_moves, current_round):
    # Cooperate for 20 rounds, then if opponent ever defected, defect forever
    if current_round < 20:
        return False
    else:
        if True in other_moves:  # if opponent ever defected
            return [True] * 200
        else:
            return False


def cooperate_at_multiples_of_three(my_moves, other_moves, current_round):
    # Cooperate only on rounds that are multiples of 3
    return [True, True, False] * 67


def alternate_every_five(my_moves, other_moves, current_round):
    # Every 5 rounds, switch between cooperate and defect
    return ([True] * 5 + [False] * 5) * 20


def suspicious_tit_for_tat(my_moves, other_moves, current_round):
    if current_round == 0:
        return True
    return other_moves[-1]

# below are two strong performing functions from previous years

_harrison_encoded = '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'

_jackson_encoded = '4wMAAAAAAAAAAAAAAAYAAAADAAAA88QBAACXAGcAZAGiAX0DfAJkAmsoAAByAXkDfAJkBGsCAAByBXwDfAIZAAAAUwBkBX0EdAEAAAAAAAAAAGQEqwEAAAAAAABEAF0TAAB9BXwBfAUZAAAAfAN8BRkAAABrKAAAcwGMD3wEZAZ6DQAAfQSMFQQAfARkB2tcAAByAXkDdAEAAAAAAAAAAHQDAAAAAAAAAAB8AasBAAAAAAAAZAh6CgAAqwEAAAAAAABEAF0RAAB9BXwBfAV8BWQIegAAABoAZwBkCaIBaygAAHMBjBEBAHkDBAB8AmQKa0QAAHI+ZAV9BnQBAAAAAAAAAABkBHQDAAAAAAAAAAB8AasBAAAAAAAAqwIAAAAAAABEAF0SAAB9B3wBfAcZAAAAcgZ8BmQGeg0AAH0GjA58BmQGehcAAH0GjBQEAHQFAAAAAAAAAAB8BqsBAAAAAAAAfAJkC3oLAABrGgAAcgF5A3wCZAx6BgAAZAVrKAAAcht0BgAAAAAAAAAAagkAAAAAAAAAAAAAAAAAAAAAAABkBmQEqwIAAAAAAABkCGtcAAByAXkDeQ18AmQMegYAAGQGaygAAHIBeQ18AmQMegYAAGQOaygAAHIBeQN5DSkPTikKRkZURkZGVEZURunHAAAAVOkKAAAA6QAAAADpAQAAAOkIAAAA6QUAAAApBVRUVFRU6Q8AAADpFAAAAOkEAAAARukCAAAAKQXaBXJhbmdl2gNsZW7aA2Fic9oGcmFuZG9t2gdyYW5kaW50KQjaB215bW92ZXPaCm90aGVybW92ZXPaDGN1cnJlbnRSb3VuZNoHcGF0dGVybtoLbmVnYXRlbm9pc2XaAWnaDXJhbmRvbUNoZWNrZXLaAWFzCAAAACAgICAgICAg+iAvdG1wL2lweXRob24taW5wdXQtMjc4NjMxNjA5NC5wedoZSmFja3NvbkxlZUFsdGVybmF0b3JOb2lzZXIaAAAA6AAAAHMvAQAAgADaDlGAR+AHE5Bz0gca2A8T4AcTkGLSBxjYDxaQfNEPJNAIJOAWF4gL3BEWkHKWGYhB2A8ZmCGJfaAHqAGhCtMPKtgQG5hx0RAgkQvwBQASG/AGAAwXmCHSCxvYExf0BgAWG5wzmHqbP6hR0Rsu1hUvkAHYEx2YYaAhoGGhJdATKNIsStMTStkbH/AFABYw8AgAEByYYtIPINggIZAN3BkemHKkM6B6oz/WGTOQQdgXIaAhkn3YGCWoEdEYKpkN4BglqBHRGCqZDfAJABo09AoAFBeQfdMTJagcuALRKTrSEzrYGx/gDxuYYdEPH6Ax0g8k3BMZlz6RPqAhoFLTEyioQdITLdgbH+AbINgRHaAB0REhoFHSESbYFxzYER2gAdERIaBR0hEm2Bcb4Bcc8wAAAAA='


import marshal
import base64
import types

def decode_and_load(encoded_string, strategy_name):
    decoded = base64.b64decode(encoded_string.encode('ascii'))
    code_obj = marshal.loads(decoded)
    func = types.FunctionType(code_obj, globals(), strategy_name)
    return func

# Load the strategies
HarrisonQian_noise_master_wrapper = decode_and_load(_harrison_encoded, 'HarrisonQian_noise_master_wrapper')

JacksonLeeAlternatorNoise = decode_and_load(_jackson_encoded, 'JacksonLeeAlternatorNoise')

"""## add your own function(s) below"""

def your_function(my_moves, other_moves, current_round):
  return True

"""## testing
To make sure your function runs correctly, replace `tit_for_tat` with the name of your function. Then, run the following code block.


"""

# Run this cell to test your code
if __name__ == "__main__":
    test_function(tit_for_tat)

    """## Inputs for the `main` function

    1. `rounds` is the number of rounds that will be played. Remember that the time it takes to calculate n rounds is proportional to n^2 (it takes about 140 seconds to calculate 10000 rounds with 13 strategies). Try starting with 150 rounds.

    2. `blindness` is a variable adjusts the percentage chance that player 1 and player 2's actions will misinterpreted. For example `[0.2, 0.5]` means player 1's actions will bee misinterpreted 20% of the time and player 2's actions will misinterpreted 50% of the time. For **no noise** this should be `[0.0, 0.0]` and for **with noise** this should be `[0.1, 0.1]`.

    3. `funcs` is a list of functions that we will want to analyze. When adding custom functions, you must type in the EXACT name of the function.

    4. `payoff` is a dictionary with tuples of two booleans as  of four numbers that set the payoffs for each outcome. The variable is organized like so: [both cooperate, you rat opponent cooperates, you cooperate opponent rats, both rat]. This should be `[5,9,0,1]`.

    There are two other variables that you don't need to worry about but you can if you want to.

    1. `seed` is an integer that acts as the random seed for any functions using the `random` or `numpy.random` modules, as well as for the noise simulation. This is useful for when you want to run noise tournaments multiple times but hold randomness constant. Defaults to `None`, meaning no seed is being used.

    ## Run Without Noise
    """

    funcs = [
        rat,
        silent,
        rand,
        kinda_random,
        tit_for_tat,
        tit_for_two_tats,
        nuke_for_tat,
        nuke_for_two_tats,
        nuke_for_five_tats,
        two_tits_for_tat,
        get_angry_after_twenty,
        cooperate_at_multiples_of_three,
        alternate_every_five,
        suspicious_tit_for_tat
    ]
    rounds = 150
    payoff = [5, 9, 0, 1]
    seed = 42

    # runs and formats the results
    start = time.time()
    data = run_no_noise_tournament(funcs, rounds, payoff, seed=seed)

    print(f"{time.time() - start} seconds to calculate")

    display_results(data)

    #This lets you analyze the precise decisions of the two players.
    display_matchup_observed_history(data, nuke_for_five_tats, alternate_every_five)

    # if you want to see the full results, use the "complete_history=True" parameter:
    display_matchup_observed_history(data, nuke_for_five_tats, alternate_every_five, complete_history=True)

    """## Run With Noise"""

    # input variables
    funcs = [
        rat,
        silent,
        rand,
        kinda_random,
        tit_for_tat,
        tit_for_two_tats,
        nuke_for_tat,
        nuke_for_two_tats,
        nuke_for_five_tats,
        get_angry_after_twenty,
        cooperate_at_multiples_of_three,
        alternate_every_five,
        HarrisonQian_noise_master_wrapper,
        JacksonLeeAlternatorNoise
    ]
    rounds = 150
    blindness = [0.1, 0.1]
    num_rounds_to_avg = 2
    payoff = [5, 9, 0, 1]
    seeds = [42, 43]

    # runs and formats the results
    start = time.time()
    data = run_noise_tournament(funcs, rounds, blindness, num_rounds_to_avg, payoff, seeds=seeds)

    print(f"{time.time() - start} seconds to calculate")

    display_results(data)

    # for noise games, there are multiple observed histories

    display_matchup_observed_history(data, nuke_for_five_tats, alternate_every_five)

    # to choose a specific one, specify the 'i' parameter to be the index that you want

    display_matchup_observed_history(data, nuke_for_five_tats, alternate_every_five, i=1, complete_history=True)